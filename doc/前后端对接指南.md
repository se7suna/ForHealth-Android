# For Health 前后端对接指南

## 概述
本文档说明如何将当前使用模拟数据的前端应用与真实后端API对接。

## 当前状态
前端目前使用 `RetrofitClient.kt` 中的模拟实现，所有API调用都返回本地模拟数据。

## 对接步骤

### 步骤1: 添加网络权限

在 `AndroidManifest.xml` 中添加网络权限：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- 添加网络权限 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <application
        ...
        android:usesCleartextTraffic="true">  <!-- 如果使用HTTP，需要添加此项 -->
        ...
    </application>
</manifest>
```

### 步骤2: 添加网络库依赖

在 `app/build.gradle.kts` 中添加Retrofit和相关依赖：

```kotlin
dependencies {
    // Retrofit
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    
    // OkHttp (用于日志和拦截器)
    implementation("com.squareup.okhttp3:okhttp:4.11.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.11.0")
    
    // Gson
    implementation("com.google.code.gson:gson:2.10.1")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

### 步骤3: 创建数据转换工具类

创建 `frontend/app/src/main/java/com/example/forhealth/utils/DataMapper.kt`：

```kotlin
package com.example.forhealth.utils

object DataMapper {
    
    // 性别转换
    fun genderToBackend(gender: String): String {
        return when (gender) {
            "男" -> "male"
            "女" -> "female"
            else -> "male"
        }
    }
    
    fun genderFromBackend(gender: String): String {
        return when (gender) {
            "male" -> "男"
            "female" -> "女"
            else -> "男"
        }
    }
    
    // 活动水平转换
    fun activityLevelToBackend(level: String): String {
        return when (level) {
            "久坐" -> "sedentary"
            "轻度活跃" -> "lightly_active"
            "中度活跃" -> "moderately_active"
            "非常活跃" -> "very_active"
            "极其活跃" -> "extremely_active"
            else -> "moderately_active"
        }
    }
    
    fun activityLevelFromBackend(level: String): String {
        return when (level) {
            "sedentary" -> "久坐"
            "lightly_active" -> "轻度活跃"
            "moderately_active" -> "中度活跃"
            "very_active" -> "非常活跃"
            "extremely_active" -> "极其活跃"
            else -> "中度活跃"
        }
    }
    
    // 目标类型转换
    fun goalTypeToBackend(type: String): String {
        return when (type) {
            "减重" -> "lose_weight"
            "维持体重" -> "maintain_weight"
            "增重" -> "gain_weight"
            else -> "maintain_weight"
        }
    }
    
    fun goalTypeFromBackend(type: String): String {
        return when (type) {
            "lose_weight" -> "减重"
            "maintain_weight" -> "维持体重"
            "gain_weight" -> "增重"
            else -> "维持体重"
        }
    }
    
    // 日期转换（出生日期）
    fun birthDateToBackend(year: Int, month: Int, day: Int): String {
        return String.format("%04d-%02d-%02d", year, month, day)
    }
}
```

### 步骤4: 创建Retrofit接口

创建 `frontend/app/src/main/java/com/example/forhealth/network/ApiInterface.kt`：

```kotlin
package com.example.forhealth.network

import com.example.forhealth.model.TokenResponse
import com.example.forhealth.model.User
import retrofit2.Response
import retrofit2.http.*

interface ApiInterface {
    
    @POST("/api/auth/login")
    suspend fun login(@Body params: Map<String, String>): Response<TokenResponse>
    
    @POST("/api/auth/register")
    suspend fun register(@Body params: Map<String, String>): Response<TokenResponse>
    
    @GET("/api/user/profile")
    suspend fun getProfile(@Header("Authorization") token: String): Response<User>
    
    @PUT("/api/user/profile")
    suspend fun updateProfile(
        @Header("Authorization") token: String,
        @Body params: Map<String, Any>
    ): Response<User>
}
```

### 步骤5: 重写RetrofitClient

替换 `frontend/app/src/main/java/com/example/forhealth/network/RetrofitClient.kt`：

```kotlin
package com.example.forhealth.network

import android.content.Context
import com.example.forhealth.model.TokenResponse
import com.example.forhealth.model.User
import com.example.forhealth.utils.PrefsHelper
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit

object RetrofitClient {
    
    // 后端服务器地址（需要根据实际情况修改）
    private const val BASE_URL = "http://10.0.2.2:8000/"  // Android模拟器访问本机
    // 如果是真机测试，需要使用电脑的局域网IP，例如：http://192.168.1.100:8000/
    
    private var context: Context? = null
    
    fun init(appContext: Context) {
        context = appContext
    }
    
    private val loggingInterceptor = HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY
    }
    
    private val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(loggingInterceptor)
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(okHttpClient)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    private val apiInterface: ApiInterface = retrofit.create(ApiInterface::class.java)
    
    val apiService: ApiService = object : ApiService {
        
        override suspend fun login(params: Map<String, String>): Result<TokenResponse> {
            return try {
                val response = apiInterface.login(params)
                if (response.isSuccessful && response.body() != null) {
                    Result.success(response.body()!!)
                } else {
                    Result.failure(Exception(response.message() ?: "登录失败"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
        
        override suspend fun register(params: Map<String, String>): Result<TokenResponse> {
            return try {
                val response = apiInterface.register(params)
                if (response.isSuccessful && response.body() != null) {
                    Result.success(response.body()!!)
                } else {
                    Result.failure(Exception(response.message() ?: "注册失败"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
        
        override suspend fun getProfile(): Result<User> {
            return try {
                val ctx = context ?: return Result.failure(Exception("未初始化"))
                val token = PrefsHelper.getToken(ctx)
                if (token.isEmpty()) {
                    return Result.failure(Exception("未登录"))
                }
                
                val response = apiInterface.getProfile("Bearer $token")
                if (response.isSuccessful && response.body() != null) {
                    Result.success(response.body()!!)
                } else {
                    Result.failure(Exception(response.message() ?: "获取用户信息失败"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
        
        override suspend fun updateProfile(params: Map<String, Any>): Result<User> {
            return try {
                val ctx = context ?: return Result.failure(Exception("未初始化"))
                val token = PrefsHelper.getToken(ctx)
                if (token.isEmpty()) {
                    return Result.failure(Exception("未登录"))
                }
                
                val response = apiInterface.updateProfile("Bearer $token", params)
                if (response.isSuccessful && response.body() != null) {
                    Result.success(response.body()!!)
                } else {
                    Result.failure(Exception(response.message() ?: "更新用户信息失败"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    fun saveToken(newToken: String) {
        context?.let { ctx ->
            PrefsHelper.saveToken(ctx, newToken)
        }
    }
}
```

### 步骤6: 初始化RetrofitClient

在 `MainActivity.kt` 中初始化：

```kotlin
class MainActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 初始化RetrofitClient
        RetrofitClient.init(applicationContext)

        val intent = Intent(this, LoginActivity::class.java)
        startActivity(intent)
        finish()
    }
}
```

### 步骤7: 更新HealthGoalActivity的数据转换

在 `HealthGoalActivity.kt` 中，保存数据前进行转换：

```kotlin
private fun saveUserData(...) {
    CoroutineScope(Dispatchers.IO).launch {
        try {
            val userData = mapOf(
                "gender" to DataMapper.genderToBackend(gender),
                "birthdate" to DataMapper.birthDateToBackend(birthYear, birthMonth, birthDay),
                "height" to height.toDouble(),
                "weight" to weight.toDouble(),
                "activity_level" to DataMapper.activityLevelToBackend(activityLevel),
                "health_goal_type" to DataMapper.goalTypeToBackend(goalType),
                "target_weight" to goalWeight.toDouble(),
                "goal_period_weeks" to goalWeeks
            )
            
            val result = RetrofitClient.apiService.updateProfile(userData)
            // ... 处理结果
        } catch (e: Exception) {
            // ... 错误处理
        }
    }
}
```

### 步骤8: 更新ProfileActivity的数据展示

在 `ProfileActivity.kt` 中，展示数据时进行转换：

```kotlin
private fun displayUserInfo(user: User) {
    tvEmail.text = "邮箱：${user.email}"
    tvGender.text = "性别：${user.gender?.let { DataMapper.genderFromBackend(it) } ?: "未设置"}"
    
    if (user.birthdate != null) {
        tvBirthDate.text = "出生日期：${user.birthdate}"
    } else {
        tvBirthDate.text = "出生日期：未设置"
    }
    
    tvHeight.text = "身高：${user.height ?: "未设置"} cm"
    tvWeight.text = "体重：${user.weight ?: "未设置"} kg"
    tvActivityLevel.text = "活动水平：${user.activity_level?.let { 
        DataMapper.activityLevelFromBackend(it) 
    } ?: "未设置"}"
    tvGoalType.text = "健康目标：${user.health_goal_type?.let { 
        DataMapper.goalTypeFromBackend(it) 
    } ?: "未设置"}"
    tvGoalWeight.text = "目标体重：${user.target_weight ?: "未设置"} kg"
    tvGoalWeeks.text = "目标周期：${user.goal_period_weeks ?: "未设置"} 周"
}
```

## 测试步骤

### 1. 启动后端服务
```bash
cd backend
uvicorn app.main:app --reload
```

### 2. 配置前端URL
根据你的测试环境修改 `RetrofitClient.kt` 中的 `BASE_URL`：
- Android模拟器访问本机：`http://10.0.2.2:8000/`
- 真机测试（需要在同一局域网）：`http://你的电脑IP:8000/`

### 3. 构建并运行应用
在Android Studio中运行应用

### 4. 功能测试
1. 测试注册功能
2. 测试登录功能
3. 测试数据填写和保存
4. 测试个人信息查看

## 常见问题

### Q1: 网络请求失败
**检查项：**
- 确认后端服务是否正常运行
- 确认BASE_URL配置是否正确
- 确认网络权限是否添加
- 检查防火墙设置

### Q2: JSON解析错误
**检查项：**
- 确认User模型字段与后端返回数据一致
- 检查Gson的字段命名策略

### Q3: 401未授权错误
**检查项：**
- 确认Token是否正确保存
- 确认Token是否过期
- 检查Authorization header格式

### Q4: 跨域问题
如果后端使用CORS，确保后端配置允许你的前端域名。

## 注意事项

1. **生产环境URL**：发布前记得修改BASE_URL为生产环境地址
2. **HTTPS**：生产环境建议使用HTTPS
3. **错误处理**：完善网络错误、超时等异常处理
4. **加载状态**：添加loading状态提示用户
5. **数据缓存**：考虑实现数据缓存减少网络请求
6. **Token刷新**：实现Token自动刷新机制

## 调试技巧

1. 使用 `HttpLoggingInterceptor` 查看请求和响应详情
2. 使用Postman测试后端API
3. 使用Android Studio的Network Profiler查看网络请求
4. 查看Logcat输出的错误信息


