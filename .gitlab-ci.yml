# GitLab CI/CD 配置文件
# For Health 后端 CI/CD Pipeline

stages:
  - test        # 测试
  - build       # 构建
  - deploy      # 部署

variables:
  PYTHON_VERSION: "3.11-slim"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  # Docker 配置优化
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  # 增加拉取超时时间（秒）
  GET_SOURCES_ATTEMPTS: 3
  RESTORE_CACHE_ATTEMPTS: 3

# 缓存配置
cache:
  paths:
    - .cache/pip
    - backend/.venv/

# ==================== Test Stage ====================

test:unit:
  stage: test
  image: python:${PYTHON_VERSION}
  services:
    - name: mongo:latest
      alias: mongo
    - name: mailhog/mailhog:latest
      alias: mailhog
  variables:
    MONGODB_URL: "mongodb://mongo:27017"
    DATABASE_NAME: "test_for_health"
    SECRET_KEY: "test-secret-key-for-ci"
    # 使用 MailHog 邮件服务器
    SMTP_HOST: "mailhog"
    SMTP_PORT: "1025"
    SMTP_USER: ""
    SMTP_PASSWORD: ""
    SMTP_FROM_EMAIL: "noreply@forhealth.com"
    SMTP_FROM_NAME: "For Health Test"
  before_script:
    - cd backend
    # 安装系统依赖 (libzbar 用于条形码识别)
    # 添加重试机制处理网络问题
    - |
      for i in {1..3}; do
        echo "🔄 尝试更新包列表 ($i/3)..."
        if apt-get update; then
          echo "✅ 包列表更新成功"
          break
        fi
        if [ $i -eq 3 ]; then
          echo "❌ 包列表更新失败，已重试3次"
          exit 1
        fi
        sleep 5
      done
    - |
      for i in {1..3}; do
        echo "🔄 尝试安装 libzbar0 ($i/3)..."
        if apt-get install -y --fix-missing libzbar0; then
          echo "✅ libzbar0 安装成功"
          break
        fi
        if [ $i -eq 3 ]; then
          echo "❌ libzbar0 安装失败，已重试3次"
          exit 1
        fi
        echo "⏳ 等待5秒后重试..."
        sleep 5
      done
    - ldconfig  # 更新动态链接库缓存
    - pip install --upgrade pip
    - pip install -r requirements.txt
    - pip install pytest pytest-asyncio httpx
  script:
    - echo "🧪 准备运行单元测试..."
    - echo "🚀 启动后端服务器..."
    # 在后台启动服务器
    - nohup uvicorn app.main:app --host 127.0.0.1 --port 8000 > server.log 2>&1 &
    - SERVER_PID=$!
    - echo "📝 服务器进程 PID:, $SERVER_PID"
    - echo "⏳ 等待服务器启动..."
    # 等待服务器启动（最多等待 30 秒）
    - |
      for i in {1..30}; do
        if curl -s http://127.0.0.1:8000/health > /dev/null 2>&1; then
          echo "✅ 服务器启动成功！"
          break
        fi
        if [ $i -eq 30 ]; then
          echo "❌ 服务器启动超时"
          cat server.log
          exit 1
        fi
        echo "等待中... ($i/30)"
        sleep 1
      done
    - echo "👤 创建测试用户..."
    # 创建测试用户（如果不存在）
    - |
      python3 << 'PYTHON_SCRIPT'
      import httpx
      import asyncio

      async def create_test_users():
          """创建多个测试用户"""
          async with httpx.AsyncClient(base_url="http://127.0.0.1:8000", timeout=30.0) as client:
              # 测试用户列表
              users = [
                  {"email": "user@example.com", "username": "testuser", "password": "string"},
                  {"email": "test@user.com", "username": "testuser2", "password": "test1234"}
              ]

              for user in users:
                  try:
                      response = await client.post("/api/auth/register", json=user)
                      if response.status_code == 201:
                          print(f"✅ 测试用户 {user['email']} 创建成功")
                      elif response.status_code == 409:
                          print(f"ℹ️ 测试用户 {user['email']} 已存在")
                      else:
                          print(f"⚠️ 创建用户 {user['email']} 返回状态码: {response.status_code}")
                  except Exception as e:
                      print(f"❌ 创建用户 {user['email']} 失败: {e}")
                      exit(1)

      asyncio.run(create_test_users())
      PYTHON_SCRIPT
    - echo "🧪 运行单元测试..."
    - pytest tests/ -v --tb=short --junitxml=test-results.xml
  after_script:
    - cd backend
    - echo "🛑 停止服务器..."
    # 停止服务器进程
    - kill $SERVER_PID || true
    - sleep 2
    # 如果还在运行，强制停止
    - kill -9 $SERVER_PID || true
    - echo "📋 服务器日志："
    - cat server.log || true
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    when: always
    paths:
      - backend/test-results.xml
    reports:
      junit: backend/test-results.xml
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  timeout: 30m
  tags:
    - docker
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml
      - docker-compose.yml

# 邮箱服务器功能测试
test:email-service:
  stage: test
  image: python:${PYTHON_VERSION}
  services:
    - name: mailhog/mailhog:latest
      alias: mailhog
  variables:
    SMTP_HOST: "mailhog"
    SMTP_PORT: "1025"
  before_script:
    - pip install --upgrade pip
    - pip install aiosmtplib
  script:
    - echo "📧 测试邮箱服务器连接和邮件发送..."
    - |
      python3 << 'EOF'
      import asyncio
      import aiosmtplib
      from email.mime.text import MIMEText
      from email.mime.multipart import MIMEMultipart

      async def test_email_connection():
          """测试邮箱服务器连接"""
          try:
              # 创建邮件
              message = MIMEMultipart()
              message["From"] = "noreply@forhealth.com"
              message["To"] = "test@example.com"
              message["Subject"] = "CI/CD 邮件服务测试"

              body = """
              <html>
                <body>
                  <h2>邮件服务器测试</h2>
                  <p>这是一封来自 CI/CD 流水线的测试邮件。</p>
                  <p>如果您收到这封邮件，说明邮件服务器工作正常！</p>
                </body>
              </html>
              """
              message.attach(MIMEText(body, "html"))

              # 发送邮件
              await aiosmtplib.send(
                  message,
                  hostname="mailhog",
                  port=1025,
              )

              print("✅ 邮件发送成功！")
              print("📬 收件人: test@example.com")
              print("📝 主题: CI/CD 邮件服务测试")
              return True
          except Exception as e:
              print(f"❌ 邮件发送失败: {e}")
              return False

      # 运行测试
      result = asyncio.run(test_email_connection())

      if result:
          print("\n🎉 邮箱服务器测试通过！")
          exit(0)
      else:
          print("\n💥 邮箱服务器测试失败！")
          exit(1)
      EOF
    - echo "✅ 邮箱服务器测试完成！"
  tags:
    - docker  # 使用带有 docker tag 的 runner
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml
      - docker-compose.yml

test:integration:
  stage: test
  image: python:${PYTHON_VERSION}
  services:
    - mongo:latest
  variables:
    MONGODB_URL: "mongodb://mongo:27017"
    DATABASE_NAME: "test_for_health"
    SECRET_KEY: "test-secret-key-for-ci"
    SMTP_HOST: "smtp.test.com"
    SMTP_USER: "test@test.com"
    SMTP_PASSWORD: "test"
    SMTP_FROM_EMAIL: "noreply@test.com"
  before_script:
    - cd backend
    - apt-get update -o Acquire::http::Proxy::deb.debian.org=http://mirrors.aliyun.com/debian -o Acquire::http::Proxy::security.debian.org=http://mirrors.aliyun.com/debian-security
    - apt-get install -y libzbar0 || apt-get install -y libzbar0 --fix-missing
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - echo "🔗 运行集成测试..."
    - nohup uvicorn app.main:app --host 127.0.0.1 --port 8000 > server.log 2>&1 &
    - SERVER_PID=$!
    - echo "📝 服务器进程 PID $SERVER_PID"
    - echo "⏳ 等待服务器启动..."
    - sleep 30
    - echo "🧪 运行单元测试..."
    - pytest --ignore=tests/test_ai_assistant.py --ignore=tests/test_example.py --ignore=tests/test_sports.py --ignore=tests/test_main.py 
  allow_failure: true
  tags:
    - docker  # 使用带有 docker tag 的 runner
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

# ==================== Build Stage ====================

build:backend:
  stage: build
  image: python:${PYTHON_VERSION}
  before_script:
    - cd backend
    # 安装系统依赖 (libzbar 用于条形码识别)
    # 添加重试机制处理网络问题
    - |
      for i in {1..3}; do
        echo "🔄 尝试更新包列表 ($i/3)..."
        if apt-get update; then
          echo "✅ 包列表更新成功"
          break
        fi
        if [ $i -eq 3 ]; then
          echo "❌ 包列表更新失败，已重试3次"
          exit 1
        fi
        sleep 5
      done
    - |
      for i in {1..3}; do
        echo "🔄 尝试安装 libzbar0 ($i/3)..."
        if apt-get install -y --fix-missing libzbar0; then
          echo "✅ libzbar0 安装成功"
          break
        fi
        if [ $i -eq 3 ]; then
          echo "❌ libzbar0 安装失败，已重试3次"
          exit 1
        fi
        echo "⏳ 等待5秒后重试..."
        sleep 5
      done
    - ldconfig  # 更新动态链接库缓存
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - echo "🏗️ 构建后端应用..."
    - python -m py_compile app/**/*.py
    - echo "✅ 构建成功"
  artifacts:
    paths:
      - backend/
    expire_in: 1 day
  tags:
    - docker  # 使用带有 docker tag 的 runner
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

# ==================== Deploy Stage ====================

deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    # 添加重试机制安装 openssh-client
    - |
      for i in 1 2 3 4 5; do
        echo "🔄 尝试安装 openssh-client ($i/5)..."
        if apk add --no-cache openssh-client; then
          echo "✅ openssh-client 安装成功"
          break
        fi
        if [ $i -eq 5 ]; then
          echo "❌ openssh-client 安装失败，已重试5次"
          exit 1
        fi
        echo "⏳ 等待 5 秒后重试..."
        sleep 5
      done
    - eval $(ssh-agent -s)
    # 验证必需的环境变量
    - |
      if [ -z "$DEPLOY_SERVER_IP" ]; then
        echo "❌ 错误: DEPLOY_SERVER_IP 环境变量未设置"
        exit 1
      fi
      if [ -z "$DEPLOY_USER" ]; then
        echo "❌ 错误: DEPLOY_USER 环境变量未设置"
        exit 1
      fi
      echo "✅ 部署服务器: $DEPLOY_USER@$DEPLOY_SERVER_IP"
    # 根据 SSH_PRIVATE_KEY 变量类型处理密钥
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # 如果 SSH_PRIVATE_KEY 是 File 类型，直接复制；如果是 Variable 类型，则写入文件
    - |
      if [ -f "$SSH_PRIVATE_KEY" ]; then
        # File 类型：SSH_PRIVATE_KEY 是文件路径
        cp "$SSH_PRIVATE_KEY" ~/.ssh/id_rsa
      else
        # Variable 类型：SSH_PRIVATE_KEY 是密钥内容
        echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
      fi
    - chmod 600 ~/.ssh/id_rsa
    - ssh-add ~/.ssh/id_rsa
    # 添加服务器到 known_hosts，添加重试和错误处理
    - |
      echo "🔍 扫描服务器 SSH 公钥..."
      for i in 1 2 3; do
        if ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts 2>/dev/null; then
          echo "✅ SSH 公钥扫描成功"
          break
        fi
        if [ $i -eq 3 ]; then
          echo "❌ SSH 公钥扫描失败，尝试跳过 known_hosts 检查"
          echo "StrictHostKeyChecking no" >> ~/.ssh/config
        else
          echo "⏳ 重试 ($i/3)..."
          sleep 2
        fi
      done
    - chmod 644 ~/.ssh/known_hosts || true
  script:
    - echo "🚀 开始部署到生产环境..."
    - |
      ssh $DEPLOY_USER@$DEPLOY_SERVER_IP << 'ENDSSH'
        set -e
        cd /opt/for_health

        echo "📥 拉取最新代码..."
        git pull origin main

        echo "🔄 重启服务..."
        docker compose -f docker-compose.prod.yml down
        docker compose -f docker-compose.prod.yml up -d --build

        echo "⏳ 等待服务启动..."
        sleep 10

        echo "🏥 健康检查..."
        if curl -f http://localhost:8000/health; then
          echo "✅ 部署成功！服务运行正常。"
        else
          echo "❌ 部署失败！服务健康检查未通过。"
          docker compose -f docker-compose.prod.yml logs --tail=50 backend
          exit 1
        fi

        echo "🧹 清理旧镜像..."
        docker image prune -f

        echo "🎉 部署完成！"
      ENDSSH
  only:
    - main
  when: manual  # 手动触发部署，确保安全
  tags:
    - docker
  environment:
    name: production
    url: http://124.70.161.90:8000

# ==================== 通知 ====================

notify:success:
  stage: .post
  script:
    - echo "✅ CI/CD Pipeline 执行成功！"
  tags:
    - jjhzhp
  when: on_success

notify:failure:
  stage: .post
  script:
    - echo "❌ CI/CD Pipeline 执行失败，请检查日志。"
  tags:
    - jjhzhp
  when: on_failure